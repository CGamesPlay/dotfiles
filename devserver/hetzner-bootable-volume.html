<!DOCTYPE html>
<!--
    This tool can be used to boot previously-created bootable volumes via a
    mobile web interface. It is a self-contained HTML application, hostable
    anywhere. For example, at:

    https://cgamesplay.com/tools/hbv.html
--->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Hetzner Bootable Volume</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css" integrity="sha384-L1dWfspMTHU/ApYnFiMz2QID/PlP1xCW9visvBdbEkOLkSSWsP6ZJWhPw6apiXxU" crossorigin="anonymous">
    <style>
        /* Mobile-First Screen System */
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100vh;
        }

        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: var(--pico-background-color);
            transform: translate3d(100%, 0, 0);
            transition: transform 0.3s ease-in-out;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        .screen[data-active="true"] {
            transform: translate3d(0, 0, 0);
            z-index: 10;
        }

        .screen[data-direction="back"] {
            transform: translate3d(-100%, 0, 0);
        }

        /* Screen Header */
        .screen > header {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            border-bottom: 1px solid var(--pico-muted-border-color);
            background: var(--pico-background-color);
            position: sticky;
            top: 0;
            z-index: 5;
        }

        .screen > header h1 {
            margin: 0;
            flex: 1;
            font-size: 1.25rem;
        }

        .screen > header button {
            margin: 0;
            padding: 0.5rem 1rem;
            min-width: 44px;
            min-height: 44px;
        }

        /* Screen Main */
        .screen > main {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
        }

        /* Screen Footer */
        .screen > footer {
            flex-shrink: 0;
            padding: 1rem;
            border-top: 1px solid var(--pico-muted-border-color);
            background: var(--pico-background-color);
            position: sticky;
            bottom: 0;
        }

        .screen > footer button {
            width: 100%;
            margin: 0;
            min-height: 50px;
        }

        /* API Key Management */
        .active-key-section {
            margin-bottom: 2rem;
        }

        .active-key-section select,
        .active-key-section button {
            width: 100%;
            margin-bottom: 0.5rem;
        }

        .key-management {
            margin-top: 2rem;
        }

        #add-key-form {
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
            margin-bottom: 1rem;
        }

        #add-key-form.collapsed {
            max-height: 0;
        }

        #add-key-form input,
        #add-key-form button {
            margin-bottom: 0.5rem;
        }

        .api-key-card {
            padding: 1rem;
            border: 2px solid var(--pico-muted-border-color);
            border-radius: var(--pico-border-radius);
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--pico-card-background-color);
        }

        .api-key-card:hover {
            border-color: var(--pico-primary);
        }

        .api-key-card-info {
            flex: 1;
            display: flex;
            align-items: center;
        }

        .api-key-card-text {
            flex: 1;
        }

        .api-key-card-name {
            font-weight: 600;
            color: var(--pico-color);
        }

        .api-key-card-actions {
            margin-left: 1rem;
        }

        .api-key-card-actions button {
            margin: 0;
        }

        /* Volume Cards */
        .volume-card {
            border: 1px solid var(--pico-muted-border-color);
            border-radius: var(--pico-border-radius);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .volume-card h2 {
            margin: 0 0 0.5rem 0;
            font-size: 1.25rem;
        }

        .volume-info {
            display: flex;
            gap: 1rem;
            margin-bottom: 0.75rem;
            font-size: 0.875rem;
            color: var(--pico-muted-color);
        }

        .status-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
        }

        .status-unattached {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status-running {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .status-off {
            background: #f5f5f5;
            color: #616161;
        }

        .status-starting, .status-stopping, .status-initializing {
            background: #fff3e0;
            color: #f57c00;
        }

        .status-deleting {
            background: #ffebee;
            color: #c62828;
        }

        .status-migrating, .status-rebuilding {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        .status-unknown {
            background: #fafafa;
            color: #9e9e9e;
        }

        .server-info {
            margin-top: 0.75rem;
        }

        .server-info .ip {
            font-family: monospace;
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background: var(--pico-muted-border-color);
            border-radius: var(--pico-border-radius);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .server-info .ip-text {
            flex: 1;
        }

        .copy-button {
            padding: 0.25rem 0.5rem;
            margin: 0;
            font-size: 0.75rem;
            min-height: auto;
        }

        .server-info select {
            width: 100%;
            margin: 0;
        }

        .boot-button {
            width: 100%;
            margin: 0;
            min-height: 44px;
        }

        /* Boot Form */
        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            margin: 0;
        }

        .checkbox-list {
            border: 1px solid var(--pico-muted-border-color);
            border-radius: var(--pico-border-radius);
            padding: 1rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .checkbox-item {
            margin-bottom: 0.75rem;
        }

        .checkbox-item:last-child {
            margin-bottom: 0;
        }

        .checkbox-item label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: normal;
            margin: 0;
            cursor: pointer;
        }

        .checkbox-item input[type="checkbox"] {
            width: auto;
            margin: 0;
            -webkit-appearance: checkbox;
            -moz-appearance: checkbox;
            appearance: checkbox;
        }

        /* Loading States */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem 1rem;
            text-align: center;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid var(--pico-muted-border-color);
            border-top-color: var(--pico-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-bottom: 1rem;
        }

        .spinner.large {
            width: 60px;
            height: 60px;
            border-width: 6px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Progress Screen */
        .progress-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 60vh;
            text-align: center;
            padding: 2rem;
        }

        .progress-container h2 {
            margin: 1rem 0 0.5rem 0;
        }

        .progress-container p {
            color: var(--pico-muted-color);
            margin: 0;
        }

        .success-icon,
        .error-icon {
            font-size: 4rem;
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            margin-bottom: 1rem;
        }

        .success-icon {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .error-icon {
            background: #ffebee;
            color: #c62828;
        }

        .ip-display {
            margin: 2rem 0;
            padding: 1.5rem;
            background: var(--pico-muted-border-color);
            border-radius: var(--pico-border-radius);
            width: 100%;
        }

        .ip-display label {
            display: block;
            font-size: 0.875rem;
            color: var(--pico-muted-color);
            margin-bottom: 0.5rem;
        }

        .ip-value {
            font-family: monospace;
            font-size: 1.5rem;
            font-weight: 600;
            word-break: break-all;
            margin-bottom: 1rem;
        }

        .ip-display button {
            width: 100%;
        }

        /* Touch Target Sizes */
        button,
        select,
        input {
            min-height: 44px;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: var(--pico-muted-color);
        }
    </style>
</head>
<body>
    <!-- Screen 1: API Key Management -->
    <div id="screen-api-keys" class="screen" data-active="true">
        <header>
            <h1>Hetzner Bootable Volume</h1>
        </header>

        <main>
            <section class="key-management">
                <button id="show-add-key">+ Add New API Key</button>

                <div id="add-key-form" class="collapsed">
                    <input type="text" id="new-key-name" placeholder="Key Name">
                    <input type="password" id="new-key-token" placeholder="API Token">
                    <button onclick="addAPIKey()">Save</button>
                    <button class="secondary" onclick="toggleAddKeyForm()">Cancel</button>
                </div>

                <div id="api-keys-list"></div>
            </section>
        </main>
    </div>

    <!-- Screen 2: Volumes List -->
    <div id="screen-volumes" class="screen">
        <header>
            <button onclick="navigateTo('screen-api-keys', 'back')">←</button>
            <h1>Volumes</h1>
            <button onclick="loadVolumes()">↻</button>
        </header>

        <main id="volumes-container">
            <div class="loading">
                <div class="spinner"></div>
                <p>Loading volumes...</p>
            </div>
        </main>
    </div>

    <!-- Screen 3: Boot Configuration -->
    <div id="screen-boot" class="screen">
        <header>
            <button onclick="navigateTo('screen-volumes', 'back')">←</button>
            <h1>Boot <span id="boot-volume-name"></span></h1>
        </header>

        <main id="boot-container">
            <div class="loading">
                <div class="spinner"></div>
                <p>Loading boot options...</p>
            </div>
        </main>

        <footer>
            <button id="boot-submit-button" onclick="confirmBoot()" disabled>Boot Volume</button>
        </footer>
    </div>

    <!-- Screen 4: Progress/Success -->
    <div id="screen-progress" class="screen">
        <main>
            <div id="progress-content" class="progress-container">
                <div class="spinner large"></div>
                <h2 id="progress-message">Creating server...</h2>
                <p id="progress-detail"></p>
            </div>
        </main>
    </div>

    <script>
        // Global State
        let currentScreen = 'screen-api-keys';
        let currentVolume = null;
        let serverTypesCache = null;
        let sshKeysCache = null;
        let firewallsCache = null;
        let imagesCache = null;

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            initApp();
        });

        function initApp() {
            loadAPIKeys();

            // Setup event listeners
            document.getElementById('show-add-key').onclick = toggleAddKeyForm;

            // Browser back button support
            window.addEventListener('popstate', (e) => {
                if (e.state && e.state.screen) {
                    showScreen(e.state.screen);
                }
            });
        }

        // Navigation
        function navigateTo(screenId, direction = 'forward') {
            const current = document.querySelector('.screen[data-active="true"]');
            const next = document.getElementById(screenId);

            if (!next) return;

            if (direction === 'back') {
                current.setAttribute('data-direction', 'back');
            } else {
                current.removeAttribute('data-direction');
            }

            current.removeAttribute('data-active');
            next.setAttribute('data-active', 'true');
            next.removeAttribute('data-direction');

            currentScreen = screenId;
            history.pushState({ screen: screenId }, '', '');
        }

        function showScreen(screenId) {
            const current = document.querySelector('.screen[data-active="true"]');
            const next = document.getElementById(screenId);

            if (!next) return;

            current.removeAttribute('data-active');
            next.setAttribute('data-active', 'true');
            currentScreen = screenId;
        }

        // API Key Management
        function loadAPIKeys() {
            renderAPIKeyList();
        }

        function renderAPIKeyList() {
            const keys = getAPIKeys();
            const list = document.getElementById('api-keys-list');
            list.innerHTML = '';

            if (keys.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <p><strong>No API keys configured.</strong></p>
                        <p>Add a Hetzner Cloud API key to get started.</p>
                        <p>This tool allows booting servers that have been previously prepared with the <a href="https://gitlab.com/CGamesPlay/dotfiles/-/tree/master/devserver" target="_blank" rel="noopener">hetzner-bootable-volume script</a>. It runs entirely client-side and API keys are stored in your browser. It is not created by or affiliated with <a href="https://www.hetzner.com" target="_blank" rel="noopener">Hetzner Online GmbH</a>.</p>
                    </div>
                `;
                return;
            }

            keys.forEach(key => {
                const card = document.createElement('div');
                card.className = 'api-key-card';
                card.innerHTML = `
                    <div class="api-key-card-info" onclick="selectAPIKey('${key.id}')">
                        <div class="api-key-card-text">
                            <div class="api-key-card-name">${escapeHtml(key.name)}</div>
                        </div>
                    </div>
                    <div class="api-key-card-actions">
                        <button class="secondary" onclick="event.stopPropagation(); deleteAPIKey('${key.id}')">Delete</button>
                    </div>
                `;
                list.appendChild(card);
            });
        }

        function selectAPIKey(id) {
            localStorage.setItem('hetzner_active_key_id', id);
            navigateTo('screen-volumes');
            loadVolumes();
        }

        function toggleAddKeyForm() {
            const form = document.getElementById('add-key-form');
            form.classList.toggle('collapsed');
            if (!form.classList.contains('collapsed')) {
                document.getElementById('new-key-name').focus();
            }
        }

        function addAPIKey() {
            const name = document.getElementById('new-key-name').value.trim();
            const token = document.getElementById('new-key-token').value.trim();

            if (!name || !token) {
                alert('Please enter both name and token');
                return;
            }

            const keys = getAPIKeys();
            const newKey = {
                id: generateId(),
                name: name,
                token: token
            };
            keys.push(newKey);
            localStorage.setItem('hetzner_api_keys', JSON.stringify(keys));

            if (keys.length === 1) {
                localStorage.setItem('hetzner_active_key_id', newKey.id);
            }

            document.getElementById('new-key-name').value = '';
            document.getElementById('new-key-token').value = '';
            toggleAddKeyForm();
            loadAPIKeys();
        }

        function deleteAPIKey(id) {
            if (!confirm('Delete this API key?')) return;

            let keys = getAPIKeys();
            keys = keys.filter(k => k.id !== id);
            localStorage.setItem('hetzner_api_keys', JSON.stringify(keys));

            if (localStorage.getItem('hetzner_active_key_id') === id) {
                localStorage.removeItem('hetzner_active_key_id');
            }

            loadAPIKeys();
        }

        function getAPIKeys() {
            const keys = localStorage.getItem('hetzner_api_keys');
            return keys ? JSON.parse(keys) : [];
        }

        function getActiveAPIToken() {
            const activeKeyId = localStorage.getItem('hetzner_active_key_id');
            if (!activeKeyId) return null;
            const keys = getAPIKeys();
            const key = keys.find(k => k.id === activeKeyId);
            return key ? key.token : null;
        }

        // Hetzner Cloud API
        async function hcloudAPI(endpoint, method = 'GET', body = null) {
            const token = getActiveAPIToken();
            if (!token) throw new Error('No API key selected');

            const response = await fetch(`https://api.hetzner.cloud/v1${endpoint}`, {
                method,
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                },
                body: body ? JSON.stringify(body) : null
            });

            const data = await response.json();
            if (!response.ok) {
                throw new Error(data.error?.message || `API error: ${response.status}`);
            }
            return data;
        }

        // Volume Management
        async function loadVolumes() {
            try {
                document.getElementById('volumes-container').innerHTML = '<div class="loading"><div class="spinner"></div><p>Loading volumes...</p></div>';

                const [volumesData, serversData] = await Promise.all([
                    hcloudAPI('/volumes'),
                    hcloudAPI('/servers')
                ]);

                const volumes = volumesData.volumes;
                const servers = serversData.servers;

                const serverMap = {};
                servers.forEach(server => {
                    serverMap[server.id] = server;
                });

                renderVolumes(volumes, serverMap);
            } catch (error) {
                console.error('Error loading volumes:', error);
                document.getElementById('volumes-container').innerHTML = `<p class="empty-state">Error: ${error.message}</p>`;
            }
        }

        function renderVolumes(volumes, serverMap) {
            const container = document.getElementById('volumes-container');

            if (volumes.length === 0) {
                container.innerHTML = '<p class="empty-state">No volumes found</p>';
                return;
            }

            container.innerHTML = '';
            volumes.forEach(volume => {
                const card = renderVolumeCard(volume, serverMap);
                container.appendChild(card);
            });
        }

        function renderVolumeCard(volume, serverMap) {
            const card = document.createElement('div');
            card.className = 'volume-card';

            const server = volume.server ? serverMap[volume.server] : null;
            const status = server ? server.status : 'unattached';

            let actionsHtml = '';
            let ipHtml = '';

            if (!server) {
                actionsHtml = `<button class="boot-button" onclick="startBootFlow(${volume.id}, '${escapeHtml(volume.name)}', '${volume.location.name}')">Boot Volume</button>`;
            } else {
                const ipv4 = server.public_net.ipv4?.ip || '';
                const ipv6 = server.public_net.ipv6?.ip || '';
                const ip = ipv4 || (ipv6 ? ipv6.replace('::/64', '::1') : 'N/A');
                ipHtml = `
                    <div class="ip">
                        <span class="ip-text">${ip}</span>
                        <button class="copy-button secondary" onclick="copyToClipboard('${ip}', this)">Copy</button>
                    </div>
                `;

                const options = [];
                if (status !== 'running') {
                    options.push('<option value="poweron">Power On</option>');
                } else {
                    options.push('<option value="poweroff">Power Off</option>');
                    options.push('<option value="reboot">Reboot</option>');
                }
                options.push('<option value="terminate">Terminate</option>');

                actionsHtml = `
                    <div class="server-info">
                        ${ipHtml}
                        <select onchange="handleVolumeAction(this.value, ${server.id}, '${escapeHtml(server.name)}', this)">
                            <option value="">Actions...</option>
                            ${options.join('')}
                        </select>
                    </div>
                `;
            }

            card.innerHTML = `
                <h2>${escapeHtml(volume.name)}</h2>
                <div class="volume-info">
                    <span class="size">${volume.size} GB</span>
                    <span class="location">${escapeHtml(volume.location.name)}</span>
                </div>
                <span class="status-badge status-${status}">${status}</span>
                ${actionsHtml}
            `;

            return card;
        }

        async function handleVolumeAction(action, serverId, serverName, selectElement) {
            if (!action) return;

            selectElement.value = '';

            if (action === 'terminate' && !confirm(`TERMINATE server "${serverName}"? This will delete the server but preserve the volume.`)) {
                return;
            }

            // Optimistically update status badge
            const card = selectElement.closest('.volume-card');
            const statusBadge = card.querySelector('.status-badge');
            const oldStatus = statusBadge.textContent;
            const oldClass = statusBadge.className;

            const optimisticStates = {
                'poweron': 'starting',
                'poweroff': 'stopping',
                'reboot': 'starting',
                'terminate': 'deleting'
            };

            const newStatus = optimisticStates[action];
            if (newStatus) {
                statusBadge.className = `status-badge status-${newStatus}`;
                statusBadge.textContent = newStatus;
            }

            try {
                if (action === 'poweron') {
                    await hcloudAPI(`/servers/${serverId}/actions/poweron`, 'POST');
                } else if (action === 'poweroff') {
                    await hcloudAPI(`/servers/${serverId}/actions/poweroff`, 'POST');
                } else if (action === 'reboot') {
                    await hcloudAPI(`/servers/${serverId}/actions/reboot`, 'POST');
                } else if (action === 'terminate') {
                    await hcloudAPI(`/servers/${serverId}`, 'DELETE');
                }
                setTimeout(() => loadVolumes(), 2000);
            } catch (error) {
                console.error('Error performing action:', error);
                // Revert optimistic update on error
                statusBadge.className = oldClass;
                statusBadge.textContent = oldStatus;
                alert(`Error: ${error.message}`);
            }
        }

        // Boot Flow
        async function startBootFlow(volumeId, volumeName, location) {
            currentVolume = { id: volumeId, name: volumeName, location: location };

            navigateTo('screen-boot');
            document.getElementById('boot-volume-name').textContent = volumeName;
            document.getElementById('boot-container').innerHTML = '<div class="loading"><div class="spinner"></div><p>Loading boot options...</p></div>';
            document.getElementById('boot-submit-button').disabled = true;

            await loadBootOptions();
        }

        async function loadBootOptions() {
            try {
                if (!serverTypesCache) {
                    const data = await hcloudAPI('/server_types');
                    serverTypesCache = data.server_types;
                }
                if (!sshKeysCache) {
                    const data = await hcloudAPI('/ssh_keys');
                    sshKeysCache = data.ssh_keys;
                }
                if (!firewallsCache) {
                    const data = await hcloudAPI('/firewalls');
                    firewallsCache = data.firewalls;
                }
                if (!imagesCache) {
                    const data = await hcloudAPI('/images?type=system');
                    imagesCache = data.images;
                }

                renderBootForm();
            } catch (error) {
                console.error('Error loading boot options:', error);
                document.getElementById('boot-container').innerHTML = `<p class="empty-state">Error: ${error.message}</p>`;
            }
        }

        function renderBootForm() {
            const prefs = getBootPrefs(currentVolume.name);

            let formHtml = '<form id="boot-form">';

            formHtml += `
                <div class="form-group">
                    <label>Server Name</label>
                    <input type="text" id="boot-server-name" value="${escapeHtml(currentVolume.name)}" required>
                </div>
            `;

            formHtml += '<div class="form-group"><label>Server Type</label><select id="boot-server-type" required>';
            serverTypesCache.forEach(type => {
                const price = parseFloat(type.prices[0].price_hourly.gross).toFixed(4);
                const selected = prefs.server_type === type.name ? 'selected' : '';
                formHtml += `<option value="${type.name}" ${selected}>${type.name} (${type.cores} cores, ${type.memory}GB RAM, €${price}/hr)</option>`;
            });
            formHtml += '</select></div>';

            formHtml += '<div class="form-group"><label>SSH Key</label><select id="boot-ssh-key" required>';
            sshKeysCache.forEach(key => {
                const selected = prefs.ssh_key === key.id.toString() ? 'selected' : '';
                formHtml += `<option value="${key.id}" ${selected}>${escapeHtml(key.name)}</option>`;
            });
            formHtml += '</select></div>';

            formHtml += '<div class="form-group"><label>Firewalls</label><div class="checkbox-list" id="boot-firewalls">';
            if (firewallsCache.length === 0) {
                formHtml += '<p style="color: var(--pico-muted-color); margin: 0;">No firewalls available</p>';
            } else {
                firewallsCache.forEach(firewall => {
                    const checked = prefs.firewalls && prefs.firewalls.includes(firewall.id.toString()) ? 'checked' : '';
                    formHtml += `
                        <div class="checkbox-item">
                            <label>
                                <input type="checkbox" name="firewall" value="${firewall.id}" ${checked}>
                                ${escapeHtml(firewall.name)}
                            </label>
                        </div>
                    `;
                });
            }
            formHtml += '</div></div>';

            formHtml += '<div class="form-group"><label>Boot Image</label><select id="boot-image" required>';
            const seenNames = new Set();
            imagesCache.forEach(image => {
                const imageName = image.name || image.id;
                if (seenNames.has(imageName)) return;
                seenNames.add(imageName);

                const selected = prefs.boot_image === imageName ? 'selected' : '';
                formHtml += `<option value="${imageName}" ${selected}>${image.description || image.name || `Image ${image.id}`}</option>`;
            });
            formHtml += '</select></div>';

            formHtml += '</form>';

            document.getElementById('boot-container').innerHTML = formHtml;
            document.getElementById('boot-submit-button').disabled = false;
        }

        async function confirmBoot() {
            if (!currentVolume) return;

            const volume = { ...currentVolume };
            const serverName = document.getElementById('boot-server-name').value.trim();
            const serverType = document.getElementById('boot-server-type').value;
            const sshKey = document.getElementById('boot-ssh-key').value;
            const bootImage = document.getElementById('boot-image').value;

            const firewallCheckboxes = document.querySelectorAll('input[name="firewall"]:checked');
            const firewalls = Array.from(firewallCheckboxes).map(cb => parseInt(cb.value));

            if (!serverName || !serverType || !sshKey || !bootImage) {
                alert('Please fill in all required fields');
                return;
            }

            saveBootPrefs(volume.name, {
                server_type: serverType,
                ssh_key: sshKey,
                firewalls: firewalls.map(f => f.toString()),
                boot_image: bootImage
            });

            navigateTo('screen-progress');
            executeBootSequence(volume, serverName, serverType, sshKey, firewalls, bootImage);
        }

        async function executeBootSequence(volume, serverName, serverType, sshKey, firewalls, bootImage) {
            try {
                updateProgress(`Creating server for ${volume.name}...`, '');

                const userData = generateCloudInit(volume.id);
                const createPayload = {
                    name: serverName,
                    server_type: serverType,
                    image: bootImage,
                    location: volume.location,
                    ssh_keys: [parseInt(sshKey)],
                    volumes: [volume.id],
                    user_data: userData,
                    start_after_create: false
                };

                if (firewalls.length > 0) {
                    createPayload.firewalls = firewalls.map(id => ({ firewall: id }));
                }

                const createResult = await hcloudAPI('/servers', 'POST', createPayload);
                const serverId = createResult.server.id;
                const createActionId = createResult.action.id;

                await waitForAction(createActionId, `Creating server for ${volume.name}`);

                updateProgress(`Attaching ${volume.name}...`, '');
                try {
                    const attachResult = await hcloudAPI(`/volumes/${volume.id}/actions/attach`, 'POST', {
                        server: serverId
                    });
                    await waitForAction(attachResult.action.id, `Attaching ${volume.name}`);
                } catch (error) {
                    if (!error.message.includes('already attached') && !error.message.includes('locked')) {
                        throw error;
                    }
                }

                updateProgress(`Powering on ${volume.name}...`, '');
                const powerResult = await hcloudAPI(`/servers/${serverId}/actions/poweron`, 'POST');
                await waitForAction(powerResult.action.id, `Powering on ${volume.name}`);

                const ipv4 = createResult.server.public_net.ipv4?.ip || '';
                const ipv6 = createResult.server.public_net.ipv6?.ip || '';
                const ip = ipv4 || (ipv6 ? ipv6.replace('::/64', '::1') : 'N/A');

                showSuccess(ip);
            } catch (error) {
                console.error('Error booting volume:', error);
                showError(error.message);
            }
        }

        async function waitForAction(actionId, progressMessage) {
            const maxAttempts = 60;
            let attempts = 0;

            while (attempts < maxAttempts) {
                const actionData = await hcloudAPI(`/actions/${actionId}`);
                const status = actionData.action.status;

                if (status === 'success') return true;
                if (status === 'error') {
                    throw new Error(actionData.action.error?.message || 'Unknown error');
                }

                attempts++;
                updateProgress(progressMessage, `${attempts}s elapsed`);
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            throw new Error('Action timed out after 60 seconds');
        }

        function updateProgress(message, detail) {
            document.getElementById('progress-message').textContent = message;
            document.getElementById('progress-detail').textContent = detail;
        }

        function showSuccess(ip) {
            const content = document.getElementById('progress-content');
            content.innerHTML = `
                <div class="success-icon">✓</div>
                <h2>Server created successfully!</h2>
                <div class="ip-display">
                    <label>IP Address</label>
                    <div class="ip-value">${ip}</div>
                    <button class="secondary" onclick="copyToClipboard('${ip}', this)">Copy IP Address</button>
                </div>
                <button onclick="navigateTo('screen-volumes', 'back'); loadVolumes();">Back to Volumes</button>
            `;
        }

        function showError(errorMessage) {
            const content = document.getElementById('progress-content');
            content.innerHTML = `
                <div class="error-icon">✗</div>
                <h2>Error</h2>
                <p>${escapeHtml(errorMessage)}</p>
                <button onclick="navigateTo('screen-volumes', 'back')">Back to Volumes</button>
            `;
        }

        // Cloud-Init Generation
        function generateCloudInit(volumeId) {
            return `#cloud-config
bootcmd:
 - |
  set -uex
  grub-editenv /boot/grub/grubenv unset recordfail
  mount /dev/disk/by-id/scsi-0HC_Volume_${volumeId}-part1 /mnt -o ro
  for i in dev sys tmp run proc; do mount --rbind /\\$i /mnt/\\$i; done
  chroot /mnt /boot/hbv-kexec
`;
        }

        // Boot Preferences
        function getBootPrefs(volumeName) {
            const prefs = localStorage.getItem('hetzner_boot_prefs');
            const allPrefs = prefs ? JSON.parse(prefs) : {};
            return allPrefs[volumeName] || { server_type: 'cpx62', boot_image: 'ubuntu-24.04' };
        }

        function saveBootPrefs(volumeName, prefs) {
            const allPrefs = JSON.parse(localStorage.getItem('hetzner_boot_prefs') || '{}');
            allPrefs[volumeName] = prefs;
            localStorage.setItem('hetzner_boot_prefs', JSON.stringify(allPrefs));
        }

        // Utility Functions
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        function maskToken(token) {
            if (token.length <= 8) return '***';
            return token.substr(0, 4) + '...' + token.substr(-4);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function copyToClipboard(text, button) {
            try {
                await navigator.clipboard.writeText(text);
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            } catch (error) {
                console.error('Failed to copy:', error);
                alert('Failed to copy to clipboard');
            }
        }
    </script>
</body>
</html>
