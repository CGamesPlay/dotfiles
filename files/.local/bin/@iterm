#!/usr/bin/env bash
# @describe iTerm2 custom escapes
# https://iterm2.com/documentation-escape-codes.html

set -eu

# @cmd Perform an arbitrary device query
# @arg    query!   Escape sequence to send
# @option --prefix Expected prefix in response (default: ESC [)
query() {
	if ! _query "${argc_query:?}" ${argc_prefix+"$argc_prefix"}; then
		echo "Terminal does not support query" >&2
		exit 1
	fi
}

# @cmd Copy to clipboard (not iTerm specific)
copy() {
	printf "\033]50;Copy=:" >/dev/tty
	trap 'printf "\a" >/dev/tty' EXIT
	base64 >/dev/tty
}

# @cmd Paste from clipboard (not iTerm specific)
paste() {
	if ! data=$(_query $'\033]52;c;?\a' $'\033]52;c;'); then
		echo "Paste denied by terminal" >&2
		exit 1
	fi

	# Strip OSC terminator (BEL or ST)
	local ST=$'\033\x5c'
	data="${data%$'\a'}"
	data="${data%"$ST"}"

	# Handle empty clipboard
	[ "$data" = "(null)" ] && exit 0

	# Decode and output
	echo "$data" | base64 -d
}

# @cmd Control a progress bar
# @flag --clear          Remove the progress bar
# @flag --indeterminate  Set the progress bar to "indeterminate" state
# @flag --warning        Set the progress bar to "warning" state
# @flag --error          Set the progress bar to "error" state
# @arg  value            Set progress bar percent
progress() {
	if [ ${argc_clear+1} ]; then
		state="0"
	elif [ ${argc_indeterminate+1} ] && [ ${argc_error+1} ]; then
		state="2"
	elif [ ${argc_indeterminate+1} ]; then
		state="3"
	elif [ ${argc_warning+1} ]; then
		state="4;${argc_value:?value required}"
	elif [ ${argc_error+1} ]; then
		state="2;${argc_value:?value required}"
	else
		state="1;${argc_value:?value required}"
	fi
	tty_printf "\033]9;4;${state}\a"
}

# @cmd Print the current color scheme (dark or light)
color-scheme() {
	if ! dsr=$(_query $'\033[?997n' $'\033['); then
		exit 1
	fi

	# Parse the response
	if [ "$dsr" = "?997;1" ]; then
		echo "dark"
	elif [ "$dsr" = "?997;2" ]; then
		echo "light"
	else
		echo "unknown"
		exit 1
	fi
}

# @cmd Check if connected to iTerm
# @option --min-version Minimum version of iTerm to accept
check() {
	if ! dsr=$(_query $'\033[1337n' $'\033['); then
		exit 1
	fi

	# Parse the response
	if [[ "$dsr" != "ITERM2 "* ]]; then
		echo "Terminal is not iTerm 2" >&2
		exit 1
	elif [ ${argc_min_version+1} ]; then
		dsr="${dsr#ITERM2 }"
		dsr="${dsr%n}"
		if [ "$(printf "%s\n%s\n" "$argc_min_version" "$dsr" | sort -V | head -n 1)" != "$argc_min_version" ]; then
			echo "iTerm 2 is too old ($dsr < $argc_min_version)" >&2
			exit 1
		fi
	fi
}

# @cmd Sets a mark
# Same as Cmd-Shift-M. Records a location so that you can jump back to it later
# (with Cmd-Shift-J)
set-mark() {
	tty_printf "\033]1337;SetMark\a"
}

# @cmd Bring iTerm2 to the foreground
steal-focus() {
	tty_printf "\033]1337;StealFocus\a"
}

# @cmd Erase the scrollback history
clear-scrollback() {
	tty_printf "\033]1337;ClearScrollback\a"
}

# @cmd Post a notification
# @option --title     Title for the notification
# @option --subtitle  Subtitle for the notification
# @arg    message!    Content of the notification
notify() {
	if [ ${argc_title+1} ] || [ ${argc_subtitle+1} ]; then
		payload="message=$(echo -n "${argc_message:?}" | base64)"
		if [ ${argc_title+1} ]; then
			payload="$payload;title=$(echo -n "${argc_title:?}" | base64)"
		fi
		if [ ${argc_subtitle+1} ]; then
			payload="$payload;subtitle=$(echo -n "${argc_subtitle:?}" | base64)"
		fi
		tty_printf "\033]1337;Notification=%s\a" "$payload"
	else
		tty_printf "\033]9;%s\a" "${argc_message:?}"
	fi
}

# @cmd Bounce the Dock icon
# @flag --forever    Bounce forever
# @flag --stop       Stop bouncing
# @flag --fireworks  Show fireworks instead
bounce() {
	param="once"
	if [ ${argc_fireworks+1} ]; then
		param="fireworks"
	elif [ ${argc_stop+1} ]; then
		param="stop"
	elif [ ${argc_forever+1} ]; then
		param="yes"
	fi
	tty_printf "\033]1337;RequestAttention=%s\a" "$param"
}

# @cmd Set badge text
#
# This is an interpolated string: https://iterm2.com/documentation-scripting-fundamentals.html#:~:text=below.-,Interpolated%20Strings,-Another
# @arg text  Text for badge
badge() {
	tty_printf "\033]1337;SetBadgeFormat=%s\a" "$(echo -n "${argc_text:-}" | base64)"
}

# @cmd Set a user variable
# @arg name!  Name of user variable
# @arg value  Value to set
set-user-var() {
	tty_printf "\033]1337;SetUserVar=%s=%s\a" "${argc_name:?}" "$(echo -n "${argc_value:-}" | base64)"
}

# @cmd Open a URL
# @arg url!  URL to open
open() {
	tty_printf "\033]1337;OpenURL=:%sa" "$(echo -n "${argc_url:?}" | base64)"
}

# @cmd Save a file or directory to the machine where iTerm2 is running
# @arg file! <FILE> File or directory to send
send-file() {
	filename="$(basename -- "${argc_file:?}")"
	if [ -d "${argc_file:?}" ]; then
		tar_file=$(mktemp)
		trap 'rm "$tar_file"' EXIT
		tar -czf "$tar_file" "$argc_file"
		argc_file="$tar_file"
		filename="$filename.tar.gz"
	fi
	st_size="$(filesize "${argc_file:?}")"
	tty_printf "\033]1337;MultipartFile=name=%s;size=%d\a" "$(echo -n "$filename" | base64)" "${st_size}"
	while read -r part; do
		tty_printf "\033]1337;FilePart=%s\a" "$part"
	done < <(base64 < "${argc_file:?}" | fold -w 200)
	tty_printf "\033]1337;FileEnd\a"
}

# @cmd Send files or directories from iTerm2 to the local machine
# @arg dest=. <DIR> Directory to place files into
receive-file() {
	# TODO: check that iterm is running
	exec 9<> /dev/tty
	_STTY=$(stty -g)
	trap 'stty "$_STTY" <&9' EXIT
	stty -echo

	printf "\033]1337;RequestUpload=format=tgz\a" >&9
	# The request/response here is actually done asynchronously, so we can't
	# use the trick of asking for a DSR to indicate no response. Also, if the
	# dialog is canceled, iTerm doesn't give any response at all.
	printf "Waiting for file selection. Press enter to cancel." >&9
	read -r status <&9
	printf "\r\033[K" >&9
	if [ "$status" != "ok" ]; then
		echo "Upload aborted" >&2
		exit 1
	fi
	tar_file=$(mktemp)
	trap 'rm "$tar_file"' EXIT
	while read -rs line <&9; do
		if [ -z "$line" ]; then
			break
		fi
		echo "$line" >> "$tar_file"
	done
	base64 -d <"$tar_file" | tar -xz -C "${argc_dest:?}"
}

# @cmd Rich file display
# @arg       file <FILE>  File to display
# @option -t --type       MIME type of the content
# @flag   -w --wide       Use horizontal scrollbar if needed
cat() {
	params="inline=1"
	if [ ${argc_file+1} ]; then
		filename="$(basename -- "${argc_file:?}")"
		st_size="$(filesize "${argc_file:?}")"
		params="$params;name=$(echo -n "$filename" | base64);size=${st_size}"
	fi
	if [ ${argc_wide+1} ]; then
		params="$params;mode=wide"
	fi
	if [ -z ${argc_file+1} ]; then
		argc_file="/dev/stdin"
	fi
	tty_printf "\033]1337;MultipartFile=%s\a" "$params"
	while read -r part; do
		tty_printf "\033]1337;FilePart=%s\a" "$part"
	done < <(base64 < "${argc_file:?}" | fold -w 200)
	tty_printf "\033]1337;FileEnd\a\n"
}

# @cmd Play a sound (custom)
# @arg sound!  Name of sound to play
play-sound() {
	tty_printf "\033]1337;Custom=id=%s:%s\a" "play-sound" "${argc_sound:?}"
}

# Perform an arbitrary DSR query
# $1: query escape sequence
# $2: expected prefix in response
_query() {
	local query="${1:?}"
	local prefix="${2:-$'\033['}"

	# Must be connected to a TTY
	if ! [ -c /dev/tty ]; then
		echo "Not connected to a TTY" >&2
		return 1
	fi

	# Set up TTY with proper cleanup
	exec 9<> /dev/tty
	local _saved_stty
	_saved_stty=$(stty -g <&9)
	stty -echo -icanon raw <&9

	# Send query followed by DSR
	printf "%s\033[5n" "$query" >&9

	# Read all bytes until we get the DSR response
	local buffer="" chunk
	while true; do
		read -r -dn chunk <&9
		buffer="$buffer${chunk}n"

		# Check if we've received the DSR response (ends with CSI 0 n)
		if [[ "$buffer" == *$'\033[0n' ]]; then
			break
		fi
	done

	# Restore TTY
	stty "$_saved_stty" <&9

	# Remove the DSR response from the end
	buffer="${buffer%$'\033[0n'}"

	# Look for the prefix in the buffer
	if [[ "${buffer}" == *"$prefix"* ]]; then
		# Extract everything after the prefix
		local result="${buffer#*"$prefix"}"
		echo "$result"
		return 0
	else
		return 1
	fi
}

# Print to the tty
tty_printf() {
	if ! [ -c /dev/tty ]; then
		echo "Not connected to a TTY" >&2
		return 1
	fi
	# shellcheck disable=SC2059
	printf "$@" >/dev/tty
}

# Get the filesize of the first argument
filesize() {
	if [[ "$(stat --version 2>&1)" =~ "GNU coreutils" ]]; then
		stat -c "%s" "$1"
	else
		# macOS
		eval "$(stat -s "${argc_file:?}")"
		echo "$st_size"
	fi
}

if ! command -v argc >/dev/null; then
	echo "This command requires argc. Install from https://github.com/sigoden/argc" >&2
	exit 100
fi
eval "$(argc --argc-eval "$0" "$@")"
