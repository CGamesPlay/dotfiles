#:schema https://jj-vcs.github.io/jj/latest/config-schema.json
# the default config is available at
# https://github.com/jj-vcs/jj/blob/main/cli/src/config/

[user]
name = "Ryan Patterson"
email = "cgamesplay@cgamesplay.com"

[ui]
# Default command. Shows commits that aren't in the main branch yet.
default-command = ["log", "-T", "log_oneline_with_status", "--config", "ui.paginate=never", "-r", "wip()", "--reversed"]
log-synthetic-elided-nodes = true
pager = ["less", "-FR"]
# We don't use delta as the main pager, because it can't handle jj's graph
# display. We do use it for cases without a graph, configured below.
diff-formatter = "delta"

[git]
private-commits = "private()"
fetch = ['regex:"origin|upstream"']

[colors]
commit_id = "magenta"
change_id = "blue"
"working_copy commit_id" = "bright magenta"
"working_copy change_id" = "bright blue"
"normal change_id" = { bold = true, fg = "cyan" }
"immutable change_id" = { bold = false, fg = "bright blue" }
empty = "bright black"
"working_copy empty" = "bright black"
"status diff modified" = "blue"
"status diff added" = "blue"
"status diff removed" = "blue"

[merge-tools.difft]
diff-args = ["--color=always", "--display=inline", "--byte-limit=100000", "$left", "$right"]

[merge-tools.delta]
diff-expected-exit-codes = [0, 1]
program = "sh"
# Delta ordinarily tries to query the terminal to determine light/dark mode,
# but it can't do that when it isn't the pager. This combines with the light
# feature (in my git config) to implement COLORFGBG, which arguably Delta
# should support natively (but doesn't).
diff-args = ["-c", """
if [ "${COLORFGBG:-0;15}" = "0;15" ]; then
  export DELTA_FEATURES=+light
fi
exec delta "$@"
""", "", "$left", "$right"]

[merge-tools.vimdiff]
program = "nvim"
diff-args = []
merge-args = [
    "-c", "let g:jj_diffconflicts_marker_length=$marker_length",
    "-c", "JJDiffConflicts!", "$output", "$base", "$left", "$right",
]
merge-tool-edits-conflict-markers = true

# For these commands, we use delta as the pager directly
[[--scope]]
--when.commands = ["diff", "show"]
[--scope.ui]
pager = "delta"
diff-formatter = ":git"

# The default status output is a disorienting rainbow of colors
[[--scope]]
--when.commands = ["status"]
[--scope.colors]
"diff modified" = "blue"
"diff added" = "blue"
"diff removed" = "blue"

[aliases]
e = ["edit"]
# Log, but shorter.
l = ["log", "-T", "log_oneline"]
# Which revision is responsible for causing the problem I'm dealing with.
blame = ["file", "annotate"]
# The official name for "rebase" feels like historical baggage.
move = ["rebase"]

# Interactively select an operation to restore
rewind = ["util", "exec", "--", "sh", "-c", '''
choice=$(jj op log -G -T 'id ++ "\x07" ++ id.short() ++ ": " ++ description ++ "\0"' | \
  fzf --read0 --delimiter='\07' --with-nth=2 --accept-nth=1 \
  --preview='jj --color=always --at-op={1}')
if [ $? -eq 0 ]; then
  jj op restore "$choice"
fi
''', "rewind"]

# Checkout a Github PR
gh-pr = ["util", "exec", "--", "sh", "-c", '''
remote="origin"
if [ $# -gt 1 ]; then
  remote="$1"
  shift
elif git remote get-url upstream >/dev/null 2>&2; then
  remote="upstream"
fi
id="${1:?Usage: jj gh-pr [REMOTE] ID}"
git fetch "$remote" "+refs/pull/$id/head:pr-$id"
jj log -T log_oneline_with_status --config ui.paginate=never -r "wip() & ::pr-$id" --reversed
''', "jj gh-pr"]

# Move some commits to prepare to push them directly to a remote branch. This
# will rebase commits given with -s/-b/-r to come before any unpushable
# commits, then update the nearest bookmark to include them. First argument may
# be a bookmark name to use instead of the nearest bookmark. All other
# arguments are passed to jj rebase; if none are given no commits are moved but
# the bookmark is still updated.
prepare = ["util", "exec", "--", "sh", "-c", """
set -eu
case ${1:--unset} in
  -*)
    bookmark="$(jj log -G -r 'closest_bookmark(@)' -T 'bookmarks.map(|b| b.name())')"
    ;;
  *)
    bookmark="$1"
    shift
    ;;
esac
if [ $# -gt 0 ]; then
  jj rebase "$@" -B "roots(closest_pushable(@)..@)"
fi
jj bookmark set --to "closest_pushable(@)" "$bookmark"
""", "jj prepare"]

# Move some commits to prepare to push them to a PR. This will rebase commits
# given with -s/-b/-r to come before any unpushable commits, in parallel with
# other changes. All arguments are passed to jj rebase.
"prepare-pr" = ["util", "exec", "--", "sh", "-c", """
set -eu
jj rebase "$@" -A 'trunk()' -B 'roots(unpushable()::@)'
""", "jj prepare-pr"]

# Open the web repo associated with this repository.
web = ["util", "exec", "--", "sh", "-c", """
if [ $# -gt 1 ]; then
  remote="$1"
elif git remote get-url upstream >/dev/null 2>/dev/null; then
  remote="upstream"
else
  remote="origin"
fi
git remote get-url "$remote" | sed -r \
  -e 's$git@gitlab.com:$https://gitlab.com/$' \
  -e 's$git@github.com:$https://github.com/$' \
  -e 's$ssh://(git@)?([^:]+)(:[0-9]+)?/$https://\\2/$' \
  | xargs $(which open || which xdg-open)
""", "jj web"]

# Move all staged changes into the parent change (requires manually adding
# changes to the git index).
squash-index = ["util", "exec", "--", "sh", "-c", """
set -e
if git diff-index --quiet --cached HEAD --; then
  echo "Nothing to do" >&2
  exit 1
fi
current_change=$(jj log --no-graph -r @ -T change_id)
tree=$(git write-tree)
jj edit @- --quiet
git restore --source="$tree" -WS -- :/
git ls-files -z --cached :/ | xargs -0 jj file track
jj edit "$current_change"
""", "jj squash-index"]
# Move all unstaged changes into a new child change (requires manually adding
# changes to the git index).
split-index = ["util", "exec", "--", "sh", "-c", """
set -e
cd "$JJ_WORKSPACE_ROOT"
unstaged_diff=$(git diff)
git checkout -- .
jj new --quiet
if [ ! -z "$unstaged_diff" ]; then
  echo "$unstaged_diff" | patch -p1 >/dev/null
  echo "Unstaged changes moved into child change."
fi
jj status
""", "jj split-index"]

[revsets]
# Default revset works just like `git log`
log = '::@'
# Give mutable commits shorter prefixes
short-prefixes = 'mutable()'

[revset-aliases]
# NOTE: revset-aliases shadow bookmarks, so it's generally a good idea to
# always use the function form.

# Mutable commits, plus remote bookmarks that we care about that and are not
# incorporated into @.
'wip()' = "ancestors(mutable() | @..tracked_remote_bookmarks(), 2)"

# Private and WIP commits that should never be pushed anywhere. Often part of
# work-in-progress merge stacks.
'private()' = "description(glob:'wip:*' | glob:'private:*')"

# Find the latest "pushable" commit to the given one. Pushable means that all
# ancestors are pushable.
'closest_pushable(to)' = 'heads(..to ~ unpushable()::)'
'unpushable()' = 'mutable() & (description(exact:"") | (empty() & ~merges()) | conflicts() | private())'
# Find the latest bookmark in the history leading to the given revs.
'closest_bookmark(to)' = 'heads(::to & tracked_remote_bookmarks())'

[templates]
log = 'log_detailed'

log_node = '''
label('node',
  coalesce(
    if(!self, label('elided', '⋮')),
    label(
      separate(' ',
        if(current_working_copy, 'working_copy'),
        if(immutable, 'immutable', 'mutable'),
        if(conflict, 'conflicted'),
        if(self.contained_in('private()'), 'private'),
      ),
      coalesce(
        if(current_working_copy, '@'),
        if(immutable, '◆'),
        if(self.contained_in('unpushable()'), '⊗'),
        if(conflict, '×'),
        '○',
      )
    )
  )
)
'''

[template-aliases]

shell_prompt = '''
separate(' ',
  coalesce(
    if(hidden, label('hidden', change_id.shortest(4) ++ ' hidden')),
    if(divergent, label('divergent', change_id.shortest(4) ++ '??')),
    change_id.shortest(4),
  ),
  commit_id.shortest(4),
  coalesce(
    if(conflict, label('conflict', '(conflict)')),
    if(empty, label('empty', '(empty)')),
  ),
  label("diff modified", count_if_present("~", diff.files().filter(|f| f.status() == "modified" || f.status() == "renamed").len())),
  label("diff added", count_if_present("+", diff.files().filter(|f| f.status() == "added" || f.status() == "copied").len())),
  label("diff removed", count_if_present("-", diff.files().filter(|f| f.status() == "removed").len())),
  coalesce(truncate_end(24, description.first_line(), '…'), description_placeholder),
)
'''
'count_if_present(prefix, value)' = 'if(value != 0, prefix ++ value)'

log_oneline = 'log_oneline(self)'
'log_oneline(commit)' = '''
if(commit.root(),
  format_root_commit(commit),
  label(
    separate(' ',
      if(commit.current_working_copy(), 'working_copy'),
      if(commit.immutable(), 'immutable', 'mutable'),
      if(commit.conflict(), 'conflicted'),
    ),
    concat(
      separate(' ',
        format_short_change_id_with_change_offset(commit),
        format_short_signature_oneline(commit.author()),
        format_short_timestamp(commit_timestamp(commit)),
        format_short_commit_id(commit.commit_id()),
        surround(
          '[',
          ']',
          separate(', ', commit.bookmarks().join(", "), commit.tags().join(", ")),
        ),
        commit.working_copies(),
        if(commit.conflict(), label('conflict', 'conflict')),
        if(config('ui.show-cryptographic-signatures').as_boolean(),
          format_short_cryptographic_signature(commit.signature())),
        if(commit.empty(), label('empty', '(empty)')),
        if(commit.description(),
          commit.description().first_line(),
          label(if(commit.empty(), 'empty'), description_placeholder),
        ),
      ) ++ "\n",
    ),
  )
)
'''

log_oneline_with_status = '''
concat(
  log_oneline(self),
  if(self.current_working_copy(),
    concat(
      label("status", diff.summary()),
      label("conflict", files.filter(|f| f.conflict()).map(|f| "‼ " ++ f.path()).join("\n"))
    ),
  )
)
'''

log_detailed = 'log_detailed(self)'
'log_detailed(commit)' = '''
concat(
  "Commit ID: " ++ commit.commit_id().shortest(100) ++ "\n",
  "Change ID: " ++ commit.change_id().shortest(100) ++ "\n",
  surround("Bookmarks: ", "\n", separate(" ", commit.local_bookmarks(), commit.remote_bookmarks())),
  surround("Tags     : ", "\n", commit.tags()),
  "Author   : " ++ format_detailed_signature(commit.author()) ++ "\n",
  "Committer: " ++ format_detailed_signature(commit.committer())  ++ "\n",
  if(config("ui.show-cryptographic-signatures").as_boolean(),
    "Signature: " ++ format_detailed_cryptographic_signature(commit.signature()) ++ "\n"),
  "\n",
  indent("    ",
    if(commit.description(),
      commit.description().trim_end(),
      label(if(commit.empty(), "empty"), description_placeholder)) ++ "\n"),
  "\n",
)
'''

'format_short_commit_header(commit)' = 'log_oneline(commit)'

'format_short_signature_oneline(signature)' = '''
if(signature.email() != config('user.email').as_string(),
  coalesce(signature.email().local(), email_placeholder))
'''
# "YYYY-MM-DD" is 10 characters, and the longest value this can print
'format_short_timestamp(timestamp)' = '''
pad_end(10, if(timestamp.after('1 week ago'),
  timestamp.ago().replace(regex:' (.).* ago', '$1 ago'),
  timestamp.format('%F')
  ))
'''
'format_timestamp(timestamp)' = "timestamp.format('%+')"

'in_branch(commit)' = "commit.contained_in('immutable_heads()..bookmarks()')"

# vim:sw=2
